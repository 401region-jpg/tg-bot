# handlers.py
import asyncio
import datetime
import logging
from cachetools import TTLCache
from aiogram import types, F, Bot
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton

from config import MIN_AGE, MAX_AGE, DESC_LIMIT, SUPERLIKE_COOLDOWN, REFERRAL_BONUS_DAYS, LAST_ACTIVE_UPDATE_MIN, ADMIN_ID, ADMIN_USERNAME
from states import ProfileStates, EditStates

logger = logging.getLogger(__name__)

# –ü—Ä–æ—Å—Ç–æ–π rate limit (–ø–∞–º—è—Ç—å –ø–æ –ø—Ä–æ—Ü–µ—Å—Å—É)
_rate = {}

def rate_limited(user_id: int) -> bool:
    now = datetime.datetime.utcnow().timestamp()
    window = LAST_ACTIVE_UPDATE_MIN * 60 if LAST_ACTIVE_UPDATE_MIN else 300
    rec = _rate.get(user_id, [])
    # keep entries in window
    rec = [t for t in rec if now - t < window]
    if len(rec) >= 6:
        _rate[user_id] = rec
        return True
    rec.append(now)
    _rate[user_id] = rec
    return False

# –ö–µ—à –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ per user for short period
profiles_cache = TTLCache(maxsize=1000, ttl=300)

def main_menu_kb():
    # ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –¥–ª—è aiogram 3.x
    kb = [
        [KeyboardButton(text="üìÑ –ú–æ—è –∞–Ω–∫–µ—Ç–∞")],
        [KeyboardButton(text="üîç –°–º–æ—Ç—Ä–µ—Ç—å –∞–Ω–∫–µ—Ç—ã"), KeyboardButton(text="‚ù§Ô∏è –ú–æ–∏ –º—ç—Ç—á–∏")],
        [KeyboardButton(text="‚úèÔ∏è –ó–∞–ø–æ–ª–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É –∑–∞–Ω–æ–≤–æ")],
        [KeyboardButton(text="üë• –ü–æ—Å–æ–≤–µ—Ç–æ–≤–∞—Ç—å –¥—Ä—É–≥—É")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def profile_action_kb(target_id: int, super_available: bool = True):
    # ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –¥–ª—è aiogram 3.x
    buttons = [
        [InlineKeyboardButton(text="‚ù§Ô∏è –ù—Ä–∞–≤–∏—Ç—Å—è", callback_data=f"like:{target_id}")],
        [InlineKeyboardButton(text="‚û°Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data=f"skip:{target_id}")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –í –º–µ–Ω—é", callback_data="menu")]
    ]
    if super_available:
        buttons.insert(1, [InlineKeyboardButton(text="üåü –°—É–ø–µ—Ä–ª–∞–π–∫", callback_data=f"superlike:{target_id}")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞ (–±—É–¥–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ register_handlers)
bot_instance: Bot = None

async def show_next_profile(viewer_id: int):
    # try cache first
    cache_key = f"profiles_for_{viewer_id}"
    if cache_key in profiles_cache:
        row = profiles_cache[cache_key].pop() if profiles_cache[cache_key] else None
    else:
        row = await db.get_next_profile(viewer_id)
    if not row:
        await db.clear_views(viewer_id)
        # refresh and try one more time
        row = await db.get_next_profile(viewer_id)
        if not row:
            await bot_instance.send_message(viewer_id, "–ê–Ω–∫–µ—Ç –Ω–µ—Ç.", reply_markup=main_menu_kb())
            return

    # determine super availability
    user = await db.user_get(viewer_id)
    super_available = False
    if user:
        extra = user.get("superlike_extra") or 0
        extra_expires = user.get("superlike_extra_expires")
        if extra and extra_expires and extra_expires > datetime.datetime.utcnow():
            super_available = True
        else:
            last = user.get("last_superlike")
            if not last or (datetime.datetime.utcnow() - last).total_seconds() > SUPERLIKE_COOLDOWN:
                super_available = True

    # send profile
    caption = f"{row.get('name') or '‚Äî'}, {row.get('age') or '‚Äî'}\n\n{(row.get('bio') or '')[:DESC_LIMIT]}"
    kb = profile_action_kb(row.get("user_id"), super_available)
    try:
        if row.get("photo_id"):
            await bot_instance.send_photo(viewer_id, row.get("photo_id"), caption=caption, reply_markup=kb)
        else:
            await bot_instance.send_message(viewer_id, caption, reply_markup=kb)
    except Exception as e:
        logger.exception("send profile failed")

async def register_handlers(dp, database, bot: Bot):
    global db, bot_instance
    db = database
    bot_instance = bot

    # start
    @dp.message(Command("start"))
    async def cmd_start(msg: types.Message, state: FSMContext):
        # ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: get_args –∑–∞–º–µ–Ω—ë–Ω –Ω–∞ split
        parts = msg.text.split()
        args = " ".join(parts[1:]) if len(parts) > 1 else ""
        ref = None
        if args.startswith("ref_"):
            try:
                ref = int(args.split("_", 1)[1])
            except:
                ref = None
        await db.user_create_if_missing(msg.from_user.id, msg.from_user.username, ref)
        # grant referral bonus
        if ref:
            ref_user = await db.user_get(ref)
            if ref_user:
                await db.user_update(ref, 
                    superlike_extra=(ref_user.get("superlike_extra", 0) + 1),
                    superlike_extra_expires=(datetime.datetime.utcnow() + datetime.timedelta(days=REFERRAL_BONUS_DAYS))
                )
        await db.user_update(msg.from_user.id, last_active=datetime.datetime.utcnow())
        # if admin and not set, set is_admin
        if msg.from_user.username and msg.from_user.username.lower() == ADMIN_USERNAME.lower():
            await db.user_update(msg.from_user.id, is_admin=True)
        u = await db.user_get(msg.from_user.id)
        if u and u.get("step") == "done":
            await msg.answer("–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º.", reply_markup=main_menu_kb())
            return
        await state.set_state(ProfileStates.name)
        await msg.answer("–í–≤–µ–¥–∏—Ç–µ –∏–º—è (3-50 —Å–∏–º–≤–æ–ª–æ–≤):", reply_markup=main_menu_kb())

    # registration FSM
    @dp.message(ProfileStates.name)
    async def reg_name(msg: types.Message, state: FSMContext):
        text = (msg.text or "").strip()
        if len(text) < 3 or len(text) > 50:
            await msg.answer("–ò–º—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 3‚Äì50 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ:")
            return
        await state.update_data(name=text)
        await state.set_state(ProfileStates.age)
        await msg.answer("–í–≤–µ–¥–∏—Ç–µ –≤–æ–∑—Ä–∞—Å—Ç (16-30):")

    @dp.message(ProfileStates.age)
    async def reg_age(msg: types.Message, state: FSMContext):
        try:
            age = int(msg.text)
        except:
            await msg.answer("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.")
            return
        if age < MIN_AGE:
            age = MIN_AGE
        if age > MAX_AGE:
            age = MAX_AGE
        await state.update_data(age=age)
        await state.set_state(ProfileStates.bio)
        await msg.answer(f"–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–¥–æ {DESC_LIMIT} —Å–∏–º–≤–æ–ª–æ–≤):")

    @dp.message(ProfileStates.bio)
    async def reg_bio(msg: types.Message, state: FSMContext):
        text = (msg.text or "")[:DESC_LIMIT]
        await state.update_data(bio=text)
        await state.set_state(ProfileStates.photo)
        await msg.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –∫–∞–∫ —Ñ–æ—Ç–æ (–Ω–µ —Ñ–∞–π–ª):")

    @dp.message(ProfileStates.photo, F.photo)
    async def reg_photo(msg: types.Message, state: FSMContext):
        data = await state.get_data()
        photo_id = msg.photo[-1].file_id
        # write to db
        await db.user_update(msg.from_user.id,
                             username=msg.from_user.username,
                             name=data["name"],
                             age=data["age"],
                             bio=data["bio"],
                             photo_id=photo_id,
                             step="done",
                             last_active=datetime.datetime.utcnow())
        await state.clear()
        await msg.answer("–ê–Ω–∫–µ—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ ‚úÖ", reply_markup=main_menu_kb())

    # show profile / browsing
    @dp.message(F.text == "üîç –°–º–æ—Ç—Ä–µ—Ç—å –∞–Ω–∫–µ—Ç—ã")
    async def browse(msg: types.Message):
        if rate_limited(msg.from_user.id):
            await msg.answer("–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ. –ü–æ–¥–æ–∂–¥–∏—Ç–µ.")
            return
        u = await db.user_get(msg.from_user.id)
        if not u or u.get("step") != "done":
            await msg.answer("–°–Ω–∞—á–∞–ª–∞ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –∞–Ω–∫–µ—Ç—É.")
            return
        await show_next_profile(msg.from_user.id)

    # callbacks: like/superlike/skip
    @dp.callback_query(lambda c: c.data and c.data.startswith(("like:", "superlike:", "skip:")))
    async def handle_reaction(cq: types.CallbackQuery):
        user_id = cq.from_user.id
        action, sid = cq.data.split(":", 1)
        try:
            target = int(sid)
        except:
            await cq.answer("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö.")
            return

        if action == "skip":
            await db.add_view(user_id, target)
            await cq.answer("–ü—Ä–æ–ø—É—â–µ–Ω–æ")
            await cq.message.delete()
            await show_next_profile(user_id)
            return

        if action == "like":
            await db.insert_like(user_id, target, "like")
            await db.add_view(user_id, target)
            mutual = await db.exists_mutual(user_id, target)
            if mutual:
                match_id = await db.create_match(user_id, target)
                # notify other: send non-invasive notice with button to view
                try:
                    await bot_instance.send_message(target, "üíå –í–∞–º –ø–æ—Å—Ç–∞–≤–∏–ª–∏ —Å–∏–º–ø–∞—Ç–∏—é! –ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å.", 
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                            [InlineKeyboardButton(text="üëÄ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å", callback_data=f"viewmatch:{match_id}")]
                        ]))
                except Exception:
                    pass
                await cq.answer("–≠—Ç–æ –º—ç—Ç—á! üéâ")
            else:
                await cq.answer("–õ–∞–π–∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω")
            await cq.message.delete()
            await show_next_profile(user_id)
            return

        if action == "superlike":
            # check availability
            u = await db.user_get(user_id)
            allowed = False
            if u:
                extra = u.get("superlike_extra") or 0
                extra_expires = u.get("superlike_extra_expires")
                if extra and extra_expires and extra_expires > datetime.datetime.utcnow():
                    allowed = True
                    await db.user_update(user_id, superlike_extra=extra - 1)
                else:
                    last = u.get("last_superlike")
                    if not last or (datetime.datetime.utcnow() - last).total_seconds() > SUPERLIKE_COOLDOWN:
                        allowed = True
                        await db.user_update(user_id, last_superlike=datetime.datetime.utcnow())

            if not allowed:
                await cq.answer("–°—É–ø–µ—Ä–ª–∞–π–∫ –¥–æ—Å—Ç—É–ø–µ–Ω 1 —Ä–∞–∑ –≤ 24 —á–∞—Å–∞ –∏–ª–∏ –ø–æ —Ä–µ—Ñ. –±–æ–Ω—É—Å—É.")
                return

            # record superlike
            await db.insert_like(user_id, target, "superlike")
            await db.add_view(user_id, target)
            mutual = await db.exists_mutual(user_id, target)
            if mutual:
                match_id = await db.create_match(user_id, target)
                # notify target that someone superliked them (with username)
                try:
                    name = (await db.user_get(user_id)).get("username") or cq.from_user.first_name
                    await bot_instance.send_message(target, f"üåü –í–∞—Å –≤—ã–±—Ä–∞–ª–∏! @{name} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª(–∞) –°—É–ø–µ—Ä–ª–∞–π–∫!", 
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                            [InlineKeyboardButton(text="üëÄ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å", callback_data=f"viewmatch:{match_id}")]
                        ]))
                except Exception:
                    pass
                await cq.answer("–°—É–ø–µ—Ä–ª–∞–π–∫ –∏ –º—ç—Ç—á!")
            else:
                try:
                    name = (await db.user_get(user_id)).get("username") or cq.from_user.first_name
                    await bot_instance.send_message(target, f"üåü –£ –≤–∞—Å —Å—É–ø–µ—Ä–ª–∞–π–∫ –æ—Ç @{name}! –ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å.", 
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                            [InlineKeyboardButton(text="üëÄ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å", callback_data="noop")]
                        ]))
                except Exception:
                    pass
                await cq.answer("–°—É–ø–µ—Ä–ª–∞–π–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.")
            await cq.message.delete()
            await show_next_profile(user_id)
            return

    # view match button handler
    @dp.callback_query(lambda c: c.data and c.data.startswith("viewmatch:"))
    async def view_match(cq: types.CallbackQuery):
        mid = int(cq.data.split(":", 1)[1])
        rows = await db.get_unshown_matches(cq.from_user.id)
        match = None
        for r in rows:
            if r["id"] == mid:
                match = r
                break
        if not match:
            await cq.answer("–ú—ç—Ç—á –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        other = match["user_b"] if match["user_a"] == cq.from_user.id else match["user_a"]
        u_other = await db.user_get(other)
        if not u_other:
            await cq.answer("–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        caption = f"–ò–º—è: {u_other.get('name')}\n–í–æ–∑—Ä–∞—Å—Ç: {u_other.get('age')}\n–û —Å–µ–±–µ: {u_other.get('bio')}"
        try:
            if u_other.get("photo_id"):
                await bot_instance.send_photo(cq.from_user.id, u_other.get("photo_id"), caption=caption)
            else:
                await bot_instance.send_message(cq.from_user.id, caption)
        except:
            pass
        await db.mark_match_shown(mid, cq.from_user.id)
        await cq.answer()

    # my matches command by button
    @dp.message(F.text == "‚ù§Ô∏è –ú–æ–∏ –º—ç—Ç—á–∏")
    async def my_matches(msg: types.Message):
        rows = await db.get_unshown_matches(msg.from_user.id)
        if not rows:
            await msg.answer("–ù–æ–≤—ã—Ö –º—ç—Ç—á–µ–π –Ω–µ—Ç.")
            return
        for r in rows:
            other = r["user_b"] if r["user_a"] == msg.from_user.id else r["user_a"]
            u = await db.user_get(other)
            if not u:
                continue
            caption = f"–ò–º—è: {u.get('name')}\n–í–æ–∑—Ä–∞—Å—Ç: {u.get('age')}\n–û —Å–µ–±–µ: {u.get('bio')}"
            if u.get("photo_id"):
                await msg.answer_photo(u.get("photo_id"), caption=caption)
            else:
                await msg.answer(caption)
            await db.mark_match_shown(r["id"], msg.from_user.id)

    # admin command: stats + broadcast
    @dp.message(Command("admin"))
    async def admin_cmd(msg: types.Message):
        # check if allowed
        allowed = False
        if msg.from_user.id == ADMIN_ID:
            allowed = True
        else:
            u = await db.user_get(msg.from_user.id)
            if u and u.get("is_admin"):
                allowed = True
        if not allowed:
            await msg.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤")
            return
        parts = (msg.text or "").split(" ", 2)
        if len(parts) >= 3 and parts[1].lower() == "message":
            body = parts[2]
            users = await db.all_users()
            sent = 0
            for u in users:
                try:
                    await bot_instance.send_message(u["user_id"], f"üì¢ –û—Ç –∞–¥–º–∏–Ω–∞:\n\n{body}")
                    sent += 1
                except:
                    pass
            await msg.answer(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent}")
            return
        # show stats: total, active last hour, matches today, new today
        users = await db.all_users()
        total = len(users)
        hour_ago = datetime.datetime.utcnow() - datetime.timedelta(hours=1)
        active = sum(1 for u in users if u.get("last_active") and datetime.datetime.fromisoformat(u["last_active"]) > hour_ago)
        # –î–ª—è matches_today –∏ new_today –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—è created_at –≤ SQLite
        await msg.answer(f"–í—Å–µ–≥–æ: {total}\n–ê–∫—Ç–∏–≤–Ω—ã—Ö (1—á): {active}\n(–ü–æ–¥—Ä–æ–±–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç—Ä–µ–±—É–µ—Ç –¥–æ—Ä–∞–±–æ—Ç–∫–∏ –ë–î)")

    # invite/referral
    @dp.message(F.text == "üë• –ü–æ—Å–æ–≤–µ—Ç–æ–≤–∞—Ç—å –¥—Ä—É–≥—É")
    async def invite(msg: types.Message):
        me = await bot_instance.get_me()
        link = f"https://t.me/{me.username}?start=ref_{msg.from_user.id}"
        await msg.answer(f"–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å—Å—ã–ª–∫–æ–π: {link}\n–ó–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –ø–æ —Å—Å—ã–ª–∫–µ —Ä–µ—Ñ–µ—Ä–µ—Ä –ø–æ–ª—É—á–∞–µ—Ç +1 –°—É–ø–µ—Ä–ª–∞–π–∫ –Ω–∞ {REFERRAL_BONUS_DAYS} –¥–Ω—è.")

    # my profile view and edit buttons
    @dp.message(F.text == "üìÑ –ú–æ—è –∞–Ω–∫–µ—Ç–∞")
    async def my_profile(msg: types.Message):
        u = await db.user_get(msg.from_user.id)
        if not u or u.get("step") != "done":
            await msg.answer("–ê–Ω–∫–µ—Ç–∞ –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞. –ù–∞–∂–º–∏—Ç–µ '–ó–∞–ø–æ–ª–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É –∑–∞–Ω–æ–≤–æ'")
            return
        caption = f"–ò–º—è: {u.get('name')}\n–í–æ–∑—Ä–∞—Å—Ç: {u.get('age')}\n–û —Å–µ–±–µ: {u.get('bio')}\n@{u.get('username')}"
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –∏–º—è", callback_data="edit_name"),
                InlineKeyboardButton(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –≤–æ–∑—Ä–∞—Å—Ç", callback_data="edit_age")
            ],
            [
                InlineKeyboardButton(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ", callback_data="edit_bio"),
                InlineKeyboardButton(text="üì∑ –ü–æ–º–µ–Ω—è—Ç—å —Ñ–æ—Ç–æ", callback_data="edit_photo")
            ],
            [
                InlineKeyboardButton(text="–ó–∞–ø–æ–ª–Ω–∏—Ç—å –∑–∞–Ω–æ–≤–æ", callback_data="re_full")
            ]
        ])
        if u.get("photo_id"):
            await msg.answer_photo(u.get("photo_id"), caption=caption, reply_markup=kb)
        else:
            await msg.answer(caption, reply_markup=kb)

    # edit callbacks
    @dp.callback_query(lambda c: c.data in ("edit_name", "edit_age", "edit_bio", "edit_photo", "re_full"))
    async def handle_edit(cq: types.CallbackQuery, state: FSMContext):
        if cq.data == "edit_name":
            await state.set_state(EditStates.edit_name)
            await cq.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∏–º—è:")
        elif cq.data == "edit_age":
            await state.set_state(EditStates.edit_age)
            await cq.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –≤–æ–∑—Ä–∞—Å—Ç:")
        elif cq.data == "edit_bio":
            await state.set_state(EditStates.edit_bio)
            await cq.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ:")
        elif cq.data == "edit_photo":
            await state.set_state(EditStates.edit_photo)
            await cq.message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ:")
        elif cq.data == "re_full":
            await state.set_state(ProfileStates.name)
            await cq.message.answer("–ù–∞—á–∏–Ω–∞–µ–º –∑–∞–Ω–æ–≤–æ. –í–≤–µ–¥–∏—Ç–µ –∏–º—è:")
        await cq.answer()

    # handlers for edit states
    @dp.message(EditStates.edit_name)
    async def do_edit_name(msg: types.Message, state: FSMContext):
        text = (msg.text or "").strip()
        if len(text) < 3 or len(text) > 50:
            await msg.answer("–ò–º—è 3-50 —Å–∏–º–≤–æ–ª–æ–≤.")
            return
        await db.user_update(msg.from_user.id, name=text)
        await state.clear()
        await msg.answer("–ò–º—è –æ–±–Ω–æ–≤–ª–µ–Ω–æ.", reply_markup=main_menu_kb())

    @dp.message(EditStates.edit_age)
    async def do_edit_age(msg: types.Message, state: FSMContext):
        try:
            age = int(msg.text)
        except:
            await msg.answer("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ")
            return
        if age < MIN_AGE:
            age = MIN_AGE
        if age > MAX_AGE:
            age = MAX_AGE
        await db.user_update(msg.from_user.id, age=age)
        await state.clear()
        await msg.answer("–í–æ–∑—Ä–∞—Å—Ç –æ–±–Ω–æ–≤–ª—ë–Ω.", reply_markup=main_menu_kb())

    @dp.message(EditStates.edit_bio)
    async def do_edit_bio(msg: types.Message, state: FSMContext):
        text = (msg.text or "")[:DESC_LIMIT]
        await db.user_update(msg.from_user.id, bio=text)
        await state.clear()
        await msg.answer("–û–ø–∏—Å–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.", reply_markup=main_menu_kb())

    @dp.message(EditStates.edit_photo, F.photo)
    async def do_edit_photo(msg: types.Message, state: FSMContext):
        pid = msg.photo[-1].file_id
        await db.user_update(msg.from_user.id, photo_id=pid)
        await state.clear()
        await msg.answer("–§–æ—Ç–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.", reply_markup=main_menu_kb())